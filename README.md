
# Алгоритмы сортировки 

**Сортировка выбором**

![alt text](https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif)

Может быть как устойчивый, так и неустойчивый алгоритм.

**Свойства**

* Худшее время	О(n^2)
* Лучшее время	О(n)
* Среднее время	О(n^2)
* Затраты памяти О(n) всего, O(1) дополнительно

**Сортировка вставками**

![alt text](https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif)

Элементы входной последовательности просматриваются по одному, и каждый новый поступивший элемент размещается в подходящее место среди ранее упорядоченных элементов

**Свойства**

* Худшее время	О(n^2)
* Лучшее время	О(n)
* Среднее время	О(n^2)
* Затраты памяти О(n) всего, O(1) вспомогательный

**Сортировка Шелла**

![alt text](https://upload.wikimedia.org/wikipedia/commons/d/d8/Sorting_shellsort_anim.gif)

Усовершенствованный вариант сортировки вставками. Идея метода Шелла состоит в сравнении элементов, стоящих не только рядом, но и на определённом расстоянии друг от друга. Иными словами — это сортировка вставками с предварительными «грубыми» проходами.

**Свойства**

* Худшее время	О(n^2)
* Лучшее время	О(n * log(n)^2)
* Среднее время	зависит от выбранных шагов
* Затраты памяти О(n) всего, O(1) вспомогательный

**Сортировка быстрая**

![alt text](https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif)

Один из самых быстрых известных универсальных алгоритмов сортировки массивов: в среднем 
O(nlogn)обменов при упорядочении n элементов; из-за наличия ряда недостатков на практике обычно используется с некоторыми доработками.

**Свойства**

* Худшее время	О(n^2)
* Лучшее время	O(n log n) (обычное разделение) или O(n) (разделение на 3 части)
* Среднее время	O(n log n)
* Затраты памяти O(log n) вспомогательных 

**Сортировка слиянием**

![alt text](https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif?uselang=ru)

Упорядочивает списки (или другие структуры данных, доступ к элементам которых можно получать только последовательно, например — потоки) в определённом порядке. Эта сортировка — хороший пример использования принципа «разделяй и властвуй». Сначала задача разбивается на несколько подзадач меньшего размера. Затем эти задачи решаются с помощью рекурсивного вызова или непосредственно, если их размер достаточно мал. Наконец, их решения комбинируются, и получается решение исходной задачи.

**Свойства**

* Худшее время	O(n log n)
* Лучшее время	O(n log n) 
* Среднее время	O(n log n)
* Затраты памяти O(n) вспомогательных 

**Сортировка поразрядная**

![alt text](http://algolist.manual.ru/sort/gif/26.gif)

